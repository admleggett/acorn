#include "byteCodeWriter.h"
#include <fstream>
#include <vector>
#include <cstdint>
#include <memory>
#include <ast/intLiteralNode.h>
#include <ast/printNode.h>

#include "codeAttribute.h"
#include "constantFieldInfo.h"
#include "constantIntegerInfo.h"
#include "constantMethodInfo.h"
#include "constantNameAndTypeInfo.h"
#include "ast/byteCodeGeneratorVisitor.h"
#include "model/classFileHeader.h"
#include "model/constantClassInfo.h"
#include "model/constantUtf8Info.h"
#include "model/constantPool.h"
#include "model/classHeaderInfo.h"
#include "model/classByteCode.h"

ByteCodeWriter::ByteCodeWriter(std::string className) : className_(std::move(className)) {}

void ByteCodeWriter::write(const std::vector<std::unique_ptr<ASTNode>>& statements, const std::string& outputFile) const
{
    // Write a minimal, valid Java class file (empty class)
    std::ofstream outFile(outputFile, std::ios::binary);
    if (!outFile) {
        throw std::runtime_error("Could not open output file for writing.");
    }

    //lambda to write a byteCodeSerializable object
    auto write = [&](const ByteCodeSerializable& entry) {
        auto bytes = entry.serialize();
        outFile.write(reinterpret_cast<const char*>(bytes.data()), bytes.size());
    };

    //get the first statement, which should be a PrintNode
    if (statements.empty()) {
        throw std::runtime_error("No statements to write.");
    }
    auto printNode = dynamic_cast<PrintNode*>(statements[0].get());


    ConstantPool constantPool;
    auto codeVector = std::vector<uint8_t>();

    //create the ASTVisitor to generate the bytecode
    auto byteCodeGenerator = ByteCodeGeneratorVisitor(constantPool, codeVector);


    ClassFileHeader header;

    // create a constant pool with entries for the classname and the superclass
    auto classInfo = std::make_shared<ConstantClassInfo>(2);
    auto className = std::make_shared<ConstantUtf8Info>("Acorn");
    auto superClassInfo = std::make_shared<ConstantClassInfo>(4);
    auto superClassName = std::make_shared<ConstantUtf8Info>("java/lang/Object");
    auto mainName = std::make_shared<ConstantUtf8Info>("main");
    auto mainDesc = std::make_shared<ConstantUtf8Info>("([Ljava/lang/String;)V");
    auto codeName = std::make_shared<ConstantUtf8Info>("Code");


    constantPool.addEntry(classInfo); // #1
    constantPool.addEntry(className); // #2
    constantPool.addEntry(superClassInfo); // #3
    constantPool.addEntry(superClassName); // #4

    byteCodeGenerator.visit(*printNode); // Generate bytecode for the print node
    auto mainIdx = constantPool.intern(mainName);
    auto mainDescIdx = constantPool.intern(mainDesc);
    auto codeIdx = constantPool.intern(codeName);


    ClassHeaderInfo classHeader(
        0x0021, // flags: public, super
        1,      // this_class: #1 (our class)
        3,      // super_class: #3 (java/lang/Object)
        0,      // interfaces_count
        0,      // fields_count
        1     // methods_count
    );

    CodeAttribute codeAttribute(
        codeIdx, // name_index: #19 ("Code")
        2,  // max_stack: 2 (for getstatic + ldc)
        1,  // max_locals: 1 (for main's String[] arg)
        codeVector // code: the generated bytecode
    );

    MethodInfo mainMethod(
        0x0009, // access_flags: public static
        mainIdx,     // name_index: #17 ("main")
        mainDescIdx,     // descriptor_index: #18 ("([Ljava/lang/String;)V")
        {std::make_shared<CodeAttribute>(codeAttribute)}      // attributes
    );

    ClassByteCode byteCode(std::make_shared<ClassFileHeader>(header),
    std::make_shared<ConstantPool>(constantPool),
    std::make_shared<ClassHeaderInfo>(classHeader),
    std::make_shared<MethodInfo>(mainMethod));

    write(byteCode);
    outFile.close();
    if (!outFile) {
        throw std::runtime_error("Error writing to output file.");
    }

}
