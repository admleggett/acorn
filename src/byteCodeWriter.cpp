#include "byteCodeWriter.h"
#include <fstream>
#include <vector>
#include <cstdint>
#include <memory>
#include <ast/intLiteralNode.h>
#include <ast/printNode.h>

#include "codeAttribute.h"
#include "constantFieldInfo.h"
#include "constantIntegerInfo.h"
#include "constantMethodInfo.h"
#include "constantNameAndTypeInfo.h"
#include "ast/byteCodeGeneratorVisitor.h"
#include "model/classFileHeader.h"
#include "model/constantClassInfo.h"
#include "model/constantUtf8Info.h"
#include "model/constantPool.h"
#include "model/classHeaderInfo.h"
#include "model/classByteCode.h"

ByteCodeWriter::ByteCodeWriter(std::string className) : className_(std::move(className)) {}

void ByteCodeWriter::write(const std::vector<std::unique_ptr<ASTNode>>& statements, const std::string& outputFile) const
{
    // Write a minimal, valid Java class file (empty class)
    std::ofstream outFile(outputFile, std::ios::binary);
    if (!outFile) {
        throw std::runtime_error("Could not open output file for writing.");
    }

    //lambda to write a byteCodeSerializable object
    auto write = [&](const ByteCodeSerializable& entry) {
        auto bytes = entry.serialize();
        outFile.write(reinterpret_cast<const char*>(bytes.data()), bytes.size());
    };

    //get the first statement, which should be a PrintNode
    if (statements.empty()) {
        throw std::runtime_error("No statements to write.");
    }
    auto printNode = dynamic_cast<PrintNode*>(statements[0].get());


    ConstantPool constantPool;
    auto codeVector = std::vector<uint8_t>();

    //create the ASTVisitor to generate the bytecode
    auto byteCodeGenerator = ByteCodeGeneratorVisitor(constantPool, codeVector);


    ClassFileHeader header;

    // create a constant pool with entries for the classname and the superclass
    std::unique_ptr<ConstantPoolEntry> classInfo = std::make_unique<ConstantClassInfo>(2);
    std::unique_ptr<ConstantPoolEntry> className = std::make_unique<ConstantUtf8Info>(this->className_);
    std::unique_ptr<ConstantPoolEntry> superClassInfo = std::make_unique<ConstantClassInfo>(4);
    std::unique_ptr<ConstantPoolEntry> superClassName = std::make_unique<ConstantUtf8Info>("java/lang/Object");
    std::unique_ptr<ConstantPoolEntry> mainName = std::make_unique<ConstantUtf8Info>("main");
    std::unique_ptr<ConstantPoolEntry> mainDesc = std::make_unique<ConstantUtf8Info>("([Ljava/lang/String;)V");
    std::unique_ptr<ConstantPoolEntry> codeName = std::make_unique<ConstantUtf8Info>("Code");


    constantPool.addEntry(std::move(classInfo)); // #1
    constantPool.addEntry(std::move(className)); // #2
    constantPool.addEntry(std::move(superClassInfo)); // #3
    constantPool.addEntry(std::move(superClassName)); // #4

    byteCodeGenerator.visit(*printNode); // Generate bytecode for the print node
    auto mainIdx = constantPool.intern(std::move(mainName));
    auto mainDescIdx = constantPool.intern(std::move(mainDesc));
    auto codeIdx = constantPool.intern(std::move(codeName));


    ClassHeaderInfo classHeader(
        0x0021, // flags: public, super
        1,      // this_class: #1 (our class)
        3,      // super_class: #3 (java/lang/Object)
        0,      // interfaces_count
        0,      // fields_count
        1     // methods_count
    );

    CodeAttribute codeAttribute(
        codeIdx, // name_index: #19 ("Code")
        2,  // max_stack: 2 (for getstatic + ldc)
        1,  // max_locals: 1 (for main's String[] arg)
        codeVector // code: the generated bytecode
    );

    std::vector<std::unique_ptr<ByteCodeSerializable>> attributes;
    attributes.push_back(std::make_unique<CodeAttribute>(codeAttribute));

    MethodInfo mainMethod(
        0x0009,
        mainIdx,
        mainDescIdx,
        std::move(attributes)
    );

    ClassByteCode byteCode(std::make_unique<ClassFileHeader>(header),
    std::make_unique<ConstantPool>(std::move(constantPool)),
    std::make_unique<ClassHeaderInfo>(std::move(classHeader)),
    std::make_unique<MethodInfo>(std::move(mainMethod)));

    write(byteCode);
    outFile.close();
    if (!outFile) {
        throw std::runtime_error("Error writing to output file.");
    }

}
